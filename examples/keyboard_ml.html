<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
  <script src="three.js"></script>
  <script src="inflate.min.js"></script>
  <script src="FBXLoader.js"></script>
  <script src="VRKeyboard.js"></script>
  <script>
    let container, scene, camera, display, model, controllerMeshes, vrKeyboard;

    const controllerGeometry = new THREE.BoxBufferGeometry(0.1, 0.2, 0.01);
    const controllerMaterial = new THREE.MeshPhongMaterial({
      color: 0x4caf50,
    });
    const _makeControllerMesh = (x = 0, y = 0, z = 0, qx = 0, qy = 0, qz = 0, qw = 1) => {
      const mesh = new THREE.Mesh(controllerGeometry, controllerMaterial);
      mesh.position.set(x, y, z);
      mesh.quaternion.set(qx, qy, qz, qw);
      // mesh.matrix.compose(mesh.position, mesh.quaternion, mesh.scale);
      mesh.updateMatrix();
      mesh.updateMatrixWorld();
      mesh.matrixAutoUpdate = false;
      mesh.frustumCulled = false;
      return mesh;
    };

    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      // scene.background = new THREE.Color(0x3B3961);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3());
      scene.add(camera);

      const ambientLight = new THREE.AmbientLight(0x808080);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setClearColor( 0x333333, 0);
      renderer.domElement.style.position = 'absolute';
      renderer.domElement.style.top = 0;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);



      // window.browser.magicleap.RequestDepthPopulation(true);
      // renderer.autoClear = false;

      container.appendChild(renderer.domElement);

      vrKeyboard = new VRKeyboard(scene, camera, renderer);


      var usernameTxt=new VRTextInput();
      usernameTxt.width=400;
      usernameTxt.placeholder="username"
      usernameTxt.position.set(0,300,0);

      vrKeyboard.addField(usernameTxt)
      vrKeyboard.target=usernameTxt;


      const loader = new THREE.FBXLoader();
      loader.load('exokit.fbx', object => {
        /* object.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0.5, 0, 1).normalize()
        ); */
        object.scale.multiplyScalar(0.001);
        object.matrix.compose(object.position, object.quaternion, object.scale);
        object.updateMatrixWorld(true);
        // object.frustumCulled = false;

        object.traverse(child => {
          child.frustumCulled = false;
        });

        model = object;

        scene.add(object);
      });

      controllerMeshes = [
        _makeControllerMesh(-0.1),
        _makeControllerMesh(0.1),
      ];
      controllerMeshes.forEach(controllerMesh => {
        scene.add(controllerMesh);
      });




      // var urlTxt = new VRTextInput();
      // urlTxt.width = 400;
      // urlTxt.position.set(0,0,1);
      //
      // vrKeyboard.addField(urlTxt);
      // vrKeyboard.target = urlTxt;




      renderer.setAnimationLoop(animate);
    }
    //
    // vrKeyboard.addEventListener("keydown", function(e){
    // if(e.code==Unicode.ENTER)
    //   console.log(urlTxt.value);
    // })


    function animate(time, frame) {
      if (model) {
        const animationTime = 4000;
        const f = ((Date.now() % animationTime) / animationTime) * (Math.PI * 2);
        model.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(Math.cos(f), 0, Math.sin(f)).normalize()
        );
        model.updateMatrixWorld();
      }
      if (renderer.vr.enabled) {
        const inputSources = display.session.getInputSources();

        for (let i = 0; i < inputSources.length; i++) {
          const inputSource = inputSources[i];
          const pose = frame.getInputPose(inputSource);

          const controllerMesh = controllerMeshes[i];
          controllerMesh.matrix.fromArray(pose.pointerMatrix);
          controllerMesh.updateMatrixWorld(true);
        }
      }
      vrKeyboard.update();

      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
    }

    init();



    (async () => {
      console.log('request device');
      display = await navigator.xr.requestDevice();
      console.log('request session');
      const session = await display.requestSession({
        exclusive: true,
      });
      display.session = session;

      session.onselect = e => {
        const controllerIndex = e.inputSource.handedness === 'left' ? 0 : 1;
        const controllerMesh = controllerMeshes[controllerIndex];
        controllerMesh.matrixWorld.decompose(controllerMesh.position, controllerMesh.quaternion, controllerMesh.scale);

        const objectMesh = _makeControllerMesh(
          controllerMesh.position.x, controllerMesh.position.y, controllerMesh.position.z,
          controllerMesh.quaternion.x, controllerMesh.quaternion.y, controllerMesh.quaternion.z, controllerMesh.quaternion.w,
        );
        scene.add(objectMesh);
      };

       console.log('request first frame');
      session.requestAnimationFrame((timestamp, frame) => {
        renderer.vr.setSession(session, {
          frameOfReferenceType: 'stage',
        });

        const viewport = session.baseLayer.getViewport(frame.views[0]);
        const width = viewport.width;
        const height = viewport.height;

        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);

        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);

        renderer.vr.setAnimationLoop(animate);


        console.log('running!');
      });
    })();
  </script>
  </body>
</html>
