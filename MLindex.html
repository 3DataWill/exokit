<!doctype html>
<html>
<head>
<meta http-equiv="origin-trial" data-feature="WebXR Device API" data-expires="2018-08-26" content="AhMYH1xq+8ln8vrOHsCIac0my75vS5E/PVqxVDSxvXM7M1/zH5vSSODn2CxYJMPvTp2weqwUvlh/aAuT5RCYggIAAABgeyJvcmlnaW4iOiJodHRwczovL3dlYm1yLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZSIsImV4cGlyeSI6MTUzNTMyMzQzMCwiaXNTdWJkb21haW4iOnRydWV9">
  <meta http-equiv="origin-trial" data-feature="WebXR Gamepad Support" data-expires="2018-08-26" content="Ap55gBYZbv4iGalsxU6jXz+KEHJPqFw/1TMCUelFSLprAGMrvdgW0OgsyeUDkmcSrmT+ccophP2RDNsg+Q8AWQcAAABoeyJvcmlnaW4iOiJodHRwczovL3dlYm1yLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkdhbWVwYWRTdXBwb3J0IiwiZXhwaXJ5IjoxNTM1MzIzNDMwLCJpc1N1YmRvbWFpbiI6dHJ1ZX0=">
  <style>
    body {
      display: flex;
      margin: 0;
      flex-direction: column;
    }
  </style>
  </script>
</head>
<body>
  <canvas id=canvas></canvas>
  <div id=container></div>
  <script src="js/three.js"></script>
  <script src="js/fetch-manager.js"></script>
  <!-- <script src="js/vr-display.js"></script> -->
  <script src="js/keycode.js"></script>
  <script src="js/svg-boundings.js"></script>
  <script>
(() => {
    const container = document.getElementById('container');
    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const DEFAULT_USER_HEIGHT = 1.6;
    const RAY_COLOR = 0x44c2ff;
    const RAY_HIGHLIGHT_COLOR = new THREE.Color(RAY_COLOR).multiplyScalar(0.5).getHex();
    const rayDistance = 10;
    const menuWidth = 2048;
    const menuHeight = 256;
    const menuWorldWidth = 2;
    const menuWorldHeight = menuWorldWidth * menuHeight / menuWidth;
    const urlBarWidth = menuWidth;
    const urlBarHeight = 200;
    const urlBarOffset = urlBarHeight*1.4;
    const fontSize = 120;
    const keyboardWidth = 2048;
    const keyboardHeight = 716;
    const keyboardMatrix = [keyboardWidth / 963.266, keyboardHeight / 337.215];
    const loadingBarWidth = menuWidth;
    const loadingBarHeight = 200;
    const loadingBarOffset = loadingBarHeight*1.4 + 202;
    let menuOpen = true;
    const fetchManager = new FetchManager();

    // const renderer = new THREE.WebGLRenderer({
    //   canvas,
    // });
    // renderer.setSize(window.innerWidth, window.innerHeight);
    // renderer.setPixelRatio(window.devicePixelRatio);
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.sortObjects = false;
    renderer.vr.enabled = true;

    container.appendChild(renderer.domElement);
    renderer.setAnimationLoop(animate);


    const _submitUrl = u => {
      currentApps = [u];
      _updateLocalApps();


      loadingBarState.loaded = false;
      loadingBarState.loading = true;
      loadingBarState.error = false;
      loadingBarState.text = 'Loading...';

      menuMesh.urlMesh.updateText();
    };
    const urlState = {
      text: 'https://docs.webmr.io/',
      cursor: -1,
      measures: [],
      submit() {
        _submitUrl(urlState.text);
      },
    };
    urlState.cursor = urlState.text.length;
    const loadingBarState = {
      text: '',
      loading: false,
      error: false,
      loaded: false,
      value: 0,
      total: 0,
      progress: 0,
    };
    let keyboardState = urlState;

    let controllerIndex = 1;
    const controllerOffsets = [
      new THREE.Vector3(),
      new THREE.Vector3(),
    ];
    const keys = {
      up: false,
      down: false,
      left: false,
      right: false,
      ctrl: false,
      alt: false,
    };

    const upVector = new THREE.Vector3(0, 1, 0);
    const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));

    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localVector3 = new THREE.Vector3();
    const localVector4 = new THREE.Vector3();
    const localVector5 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localQuaternion2 = new THREE.Quaternion();
    const localEuler = new THREE.Euler();
    localEuler.order = 'YXZ';
    const localEuler2 = new THREE.Euler();
    localEuler2.order = localEuler.order;
    const localMatrix = new THREE.Matrix4();


    const scene = new THREE.Scene();
    scene.matrixAutoUpdate = false;

    // const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10 * 1024);
    // camera.position.set(0, DEFAULT_USER_HEIGHT, 1);
    // camera.rotation.order = 'YXZ';
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    // camera.position.set(0, 1, 0);
    camera.lookAt(new THREE.Vector3());
    scene.add(camera);


    const fakeDisplay = window.navigator.createVRDisplay();
    fakeDisplay.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
    fakeDisplay.getEyeParameters = (getEyeParameters => function(eye) {
      if (!fakeDisplay.getStereo() && eye === 'right') {
        const result = getEyeParameters.call(this, 'right');
        result.renderWidth = 0;
        return result;
      } else {
        return getEyeParameters.apply(this, arguments);
      }
    })(fakeDisplay.getEyeParameters);
    fakeDisplay.position.copy(camera.position);
    fakeDisplay.quaternion.copy(camera.quaternion);
    camera.projectionMatrix.toArray(fakeDisplay._frameData.leftProjectionMatrix);
    camera.projectionMatrix.toArray(fakeDisplay._frameData.rightProjectionMatrix);
    fakeDisplay.stereo = false;
    fakeDisplay.update();
    if (window.tickAnimationFrame) {
      fakeDisplay.onrequestanimationframe = fn => window.tickAnimationFrame.window.requestAnimationFrame(fn, 1);
    } else {
      fakeDisplay.onrequestanimationframe = fn => window.requestAnimationFrame(fn, 1);
    }
    fakeDisplay.onvrdisplaypresentchange = () => {
      setTimeout(() => {
        const e = new Event('vrdisplaypresentchange');
        e.display = fakeDisplay;
        window.dispatchEvent(e);
      });
    };
    const _enterFakeDisplay = (stereo = false) => {
      if (fakeDisplay.session) {
        fakeDisplay.session.end();
      }

      fakeDisplay.requestPresent([{source: canvas}])
        .then(() => {
          renderer.vr.setDevice(fakeDisplay);
          renderer.vr.setAnimationLoop(animate);

          if (navigator.xr) {
            const views = !stereo ? [{
              eye: 'left',
              projectionMatrix: fakeDisplay._frameData.leftProjectionMatrix,
              _viewport: {
                x: 0,
                y: 0,
                width: fakeDisplay._width,
                height: fakeDisplay._height,
              },
            }] : [
              {
                eye: 'left',
                projectionMatrix: fakeDisplay._frameData.leftProjectionMatrix,
                _viewport: {
                  x: 0,
                  y: 0,
                  width: fakeDisplay._width / 2,
                  height: fakeDisplay._height,
                },
              },
              {
                eye: 'right',
                projectionMatrix: fakeDisplay._frameData.rightProjectionMatrix,
                _viewport: {
                  x: fakeDisplay._width / 2,
                  y: 0,
                  width: fakeDisplay._width / 2,
                  height: fakeDisplay._height,
                }
              },
            ];
            const devicePose = {
              getViewMatrix(view) {
                return fakeDisplay._frameData[view.eye === 'left' ? 'leftViewMatrix' : 'rightViewMatrix'];
              },
            };
            const frame = {
              views,
              getDevicePose() {
                return devicePose;
              },
            };
            const onends = [];
            const session = {
              addEventListener(e, fn) {
                if (e === 'end') {
                  onends.push(fn);
                }
              },
              baseLayer: null,
              requestFrameOfReference() {
                return Promise.resolve(stereo ? {} : null);
              },
              device: fakeDisplay,
              requestAnimationFrame: fn => window.requestAnimationFrame(timestamp => {
                fn(timestamp, frame);
              }, 1),
              end() {
                for (let i = 0; i < onends.length; i++) {
                  onends[i]();
                }
                return fakeDisplay.exitPresent();
              },
            };
            fakeDisplay.session = session;
            renderer.vr.setSession(session, {
              frameOfReferenceType: 'stage',
            });
          } else {
            window.dispatchEvent(new Event('vrdisplaypresentchange'));
          }

          fakeDisplay.stereo = stereo;
        });
    };
    _enterFakeDisplay();

    const _getGamepads = () => {
      if (fakeDisplay.isPresenting) {
        return fakeDisplay.gamepads;
      } else {
        return navigator.getGamepads();
      }
    };

    const _makeRenderTarget = (width, height) => {
      const renderTarget = new THREE.WebGLRenderTarget(width, height);
      renderTarget.depthTexture = new THREE.DepthTexture(
        width,
        height,
        THREE.UnsignedInt248Type,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        1,
        THREE.DepthStencilFormat
      );
      return renderTarget;
    };
    let renderTarget = _makeRenderTarget(canvas.width, canvas.height);



    const ambientLight = new THREE.AmbientLight(0x808080);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const controllerMeshes = [null, null];
    const lastPresseds = [false, false];
    const lastMenuPresseds = [false, false];
    const grabbedObjects = [null, null];
    for (let i = 0; i < 2; i++) {
      const controllerMesh = new THREE.Object3D();
      controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 1, 0.5);
      controllerMesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0, -1, -1)
      );

      const rayMesh = (() => {
        const geometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
          .applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2))
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));
        const material = new THREE.MeshBasicMaterial({
          color: RAY_COLOR,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.visible = i === 1;
        return mesh;
      })();
      controllerMesh.add(rayMesh);
      controllerMesh.rayMesh = rayMesh;

      const rayDot = (() => {
        const geometry = new THREE.SphereBufferGeometry(0.01, 5, 5);
        const material = new THREE.MeshBasicMaterial({
          color: 0xe91e63,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.z = -1;
        mesh.visible = false;
        return mesh;
      })();
      controllerMesh.add(rayDot);
      controllerMesh.rayDot = rayDot;

      controllerMesh.ray = new THREE.Ray();
      controllerMesh.update = () => {
        controllerMesh.ray.origin.copy(controllerMesh.position);
        controllerMesh.ray.direction
          .set(0, 0, -1)
          .applyQuaternion(controllerMesh.quaternion);
      };

      scene.add(controllerMesh);
      controllerMeshes[i] = controllerMesh;
    }




    const animations = [];
    const _mod = (v, d) => {
      const n = v % d;
      return n < 0 ? (d + n) : n;
    };
    const _angleDiff = (a, b) => _mod((b - a) + Math.PI, Math.PI * 2) - Math.PI;


    let menuImg = null;
    let menuMetrics = null;
    const _renderHtml = u => {
      window.drawWindow && window.drawWindow(`html/${u}`, menuWidth, menuHeight)
        .then(({img, metrics}) => {
          menuImg = img;
          menuMetrics = metrics;

          menuMesh.urlMesh.updateText();
        })
        .catch(err => {
          console.warn(err.stack);
        });
    };
    // _renderHtml('menu.html?t=url');

    const tabs = ['URL'];
    const cursorWidth = 10;
    const _getTab = () => {
      if (currentTabIndex >= 0) {
        return tabs[currentTabIndex];
      } else {
        return null;
      }
    };
    let currentTabIndex = 0;


    const menuMesh = (() => {
      const object = new THREE.Object3D();
      object.position.copy(camera.position).add(new THREE.Vector3(0, 0.5, -2));

      const urlMesh = (() => {
        const canvas = document.createElement('canvas');
        canvas.width = menuWidth;
        canvas.height = menuHeight;
        const ctx = canvas.getContext('2d');

        const geometry = new THREE.PlaneBufferGeometry(menuWorldWidth, menuWorldHeight);
        const texture = new THREE.Texture(
          canvas,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          1
        );
        texture.needsUpdate = true;
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true,
          alphaTest: 0.9,
        });
        const mesh = new THREE.Mesh(geometry, material);

        const _updateText = () => {
          ctx.fillStyle = '#EEE';
          ctx.fillRect(0, 0, menuWidth, menuHeight*2);


          const tab = _getTab();
          if (tab === 'URL') {
            ctx.fillStyle = '#563156';
            ctx.fillRect(0, 0, urlBarWidth, 2048);
            //                    .set(0, -0.5, -1)

//            ctx.fillStyle = '#RFF';
//            ctx.fillRect(5, urlBarOffset + 500, urlBarWidth - 10, urlBarHeight - 10);

            if (loadingBarState.loading && !loadingBarState.error && !loadingBarState.loaded) {
              ctx.fillStyle = '#e68e04';
              ctx.fillRect(0, loadingBarOffset, loadingBarWidth, loadingBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(10, loadingBarOffset, loadingBarWidth -20, loadingBarHeight- 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(loadingBarState.text, 10, loadingBarOffset + loadingBarHeight - 10*2 - 30);
            }
            if (loadingBarState.loaded && loadingBarState.error) {
              ctx.fillStyle = '#1dc008';
              ctx.fillRect(0, loadingBarOffset, loadingBarWidth, loadingBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(10, loadingBarOffset, loadingBarWidth -20, loadingBarHeight- 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(loadingBarState.text, 10, loadingBarOffset + loadingBarHeight - 10*2 - 30);
            }
            if (loadingBarState.loading && loadingBarState.loaded && loadingBarState.error) {
              ctx.fillStyle = '#ff1818';
              ctx.fillRect(0, loadingBarOffset, loadingBarWidth, loadingBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(10, loadingBarOffset, loadingBarWidth -20, loadingBarHeight- 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(loadingBarState.text, 10, loadingBarOffset + loadingBarHeight - 10*2 - 30);
            }

            ctx.fillStyle = '#FFF';
            ctx.font = `${fontSize}px Arial`;
            ctx.fillText(urlState.text, 10, urlBarHeight - 10*2 - 30);

            urlState.measures.length = 0;
            urlState.measures.push(0);
            const {width: barWidth} = ctx.measureText('[');
            for (let i = 1; i <= urlState.text.length; i++) {
              const {width} = ctx.measureText('[' + urlState.text.slice(0, i) + ']');
              urlState.measures.push(width - barWidth*2);
            }

            ctx.fillStyle = '#03a9f4';
            ctx.fillRect(20 + urlState.measures[urlState.cursor] - cursorWidth/2, 30, cursorWidth, urlBarHeight - 20*2);

            if (menuImg) {
              ctx.drawImage(menuImg, 0, menuHeight - menuImg.height, menuImg.width, menuImg.height);
            }
          }



          texture.needsUpdate = true;
        };
        _updateText();
        mesh.updateText = _updateText;

        mesh.plane = new THREE.Plane();
        mesh.leftLine = new THREE.Line3();
        mesh.topLine = new THREE.Line3();
        mesh.update = () => {
          mesh.leftLine.start
            .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
            .applyMatrix4(mesh.matrixWorld);
          mesh.leftLine.end
            .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
            .applyMatrix4(mesh.matrixWorld);

          mesh.topLine.start
            .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
            .applyMatrix4(mesh.matrixWorld);
          mesh.topLine.end
            .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
            .applyMatrix4(mesh.matrixWorld);

          mesh.plane.setFromCoplanarPoints(
            mesh.leftLine.start,
            mesh.leftLine.end,
            mesh.topLine.end
          );
        };

        return mesh;
      })();
      object.add(urlMesh);
      object.urlMesh = urlMesh;

      return object;
    })();
    scene.add(menuMesh);



    const keyboardMesh = (() => {
      const object = new THREE.Object3D();

      const planeMesh = (() => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = 'img/keyboard.png';
        img.onload = () => {
          texture.needsUpdate = true;
        };
        img.onerror = err => {
          console.warn(err.stack);
        };

        const geometry = new THREE.PlaneBufferGeometry(1, keyboardHeight / keyboardWidth);
        const texture = new THREE.Texture(
          img,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          1
        );
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true,
          alphaTest: 0.9,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 1, 1).normalize()
        );
        return mesh;
      })();
      object.add(planeMesh);
      object.planeMesh = planeMesh;

      object.plane = new THREE.Plane();
      object.leftLine = new THREE.Line3();
      object.topLine = new THREE.Line3();
      object.update = () => {
        object.leftLine.start
          .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);
        object.leftLine.end
          .set(-1/2, -keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);

        object.topLine.start
          .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);
        object.topLine.end
          .set(1/2, keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);

        object.plane.setFromCoplanarPoints(
          object.leftLine.start,
          object.leftLine.end,
          object.topLine.end
        );
      };

      return object;
    })();
    keyboardMesh.position.set(0, 0.5, 0);
    scene.add(keyboardMesh);

    let keyboardMeshAnimation = null;

    for (let i = 0; i < controllerMeshes.length; i++) {
      const controllerMesh = controllerMeshes[i];

      const keyMesh = (() => {
        const geometry = new THREE.PlaneBufferGeometry(1, 1);
        const texture = new THREE.Texture(
          null,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          1
        );
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true,
        });
        const mesh = new THREE.Mesh(geometry, material);
        return mesh;
      })();
      keyboardMesh.planeMesh.add(keyMesh);

      controllerMesh.keyMesh = keyMesh;
    }

    let keyboardHighlightCanvasCtx = null;
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = 'img/keyboard-hightlight.svg';
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      keyboardHighlightCanvasCtx = ctx;
    };
    img.onerror = err => {
      console.log(err.stack);
    };

    const keyMap = [];
    fetch('img/keyboard.svg')
      .then(res => res.text())
      .then(keyboardText => {
        const div = document.createElement('div');
        div.innerHTML = keyboardText;
        const keyEls = div.querySelectorAll('svg > g[key]');
        for (let i = 0; i < keyEls.length; i++) {
          const keyEl = keyEls[i];
          const key = keyEl.getAttribute('key');
          const shapeEl = keyEl.children[0];
          const boundings = svgBoundings[shapeEl.tagName.toLowerCase()](shapeEl);
          const {
            left,
            right,
            top,
            bottom,
          } = boundings;
          const x1 = left * keyboardMatrix[0];
          const x2 = right * keyboardMatrix[0];
          const y1 = top * keyboardMatrix[1];
          const y2 = bottom * keyboardMatrix[1];
          keyMap.push([key, x1, y1, x2, y2]);
        }
      })
      .catch(err => {
        console.warn(err.stack);
      });


    let lastTime = Date.now();
    const _updateGamepads = () => {
      for (let i = 0; i < 2; i++) {
        const gamepad = fakeDisplay.gamepads[i];
        if (gamepad) {
          const controllerOffset = controllerOffsets[i];

          localVector.copy(fakeDisplay.position)
            .add(
              localVector2.set(-0.1 + (i*0.1*2), -0.1, -0.2)
                .add(controllerOffset)
                .applyQuaternion(fakeDisplay.quaternion)
            ).toArray(gamepad.pose.position);
          fakeDisplay.quaternion.toArray(fakeDisplay.gamepads[i].pose.orientation);
        }
      }
    };
    const _render = () => {


      const device = renderer.vr.getDevice();
      if (device && device.constructor.name === 'FakeVRDisplay') {
        camera.position.copy(device.position);
        camera.quaternion.copy(device.quaternion);

        renderer.render(scene, camera, renderTarget);
      } else {
        renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
      }

      renderer.vr.enabled = false;
      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
      renderer.vr.enabled = true;
    };
    function animate() {
      const currentTime = Date.now();
      const timePassed = Math.max(currentTime - lastTime, 1);
      lastTime = currentTime;

      const _updateControllers = () => {
        const gamepads = _getGamepads();

        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (gamepad) {
            const controllerMesh = controllerMeshes[i];
            controllerMesh.position.fromArray(gamepad.pose.position);
            controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
            controllerMesh.updateMatrixWorld();
          }
        }
      };
      const _updateIntersections = () => {
        keyboardMesh.update();
        menuMesh.urlMesh.update();

        const gamepads = _getGamepads();

        for (let i = 0; i < 2; i++) {
          if (fakeDisplay.isPresenting && i !== controllerIndex) {
            continue;
          }

          const controllerMesh = controllerMeshes[i];
          controllerMesh.update();

          const gamepad = gamepads[i];
          let pressed = false;
          let grabbed = false;
          let menuPressed = false;
          let padPressed = null;
          if (gamepad) {
            pressed = gamepad.buttons[1].pressed;
            grabbed = gamepad.buttons[2].pressed;
            menuPressed = gamepad.buttons[3].pressed;
            padPressed = gamepad.buttons[0].pressed ? _getGamepadDirection(gamepad) : null;
          }

          const _setIntersectionDefault = () => {
            controllerMesh.rayMesh.scale.z = rayDistance;
            controllerMesh.rayMesh.updateMatrixWorld();

            controllerMesh.rayDot.visible = false;

            controllerMesh.keyMesh.visible = false;

          };

          // keyboard
          let intersectionPoint = keyboardMesh.visible ? controllerMesh.ray.intersectPlane(keyboardMesh.plane, localVector) : null;
          let intersectionKey = null;
          if (intersectionPoint) {
            const leftIntersectionPoint = keyboardMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

            const topIntersectionPoint = keyboardMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

            const xFactor = topIntersectionPoint.distanceTo(keyboardMesh.topLine.start) / (1);
            const yFactor = leftIntersectionPoint.distanceTo(keyboardMesh.leftLine.start) / (keyboardHeight / keyboardWidth);
            const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

            if (xFactor > 0 && xFactor <= 0.99 && yFactor > 0 && yFactor <= 0.99 && distance < rayDistance) {
              const x = xFactor * keyboardWidth;
              const y = yFactor * keyboardHeight;

              controllerMesh.rayMesh.scale.z = distance;
              controllerMesh.updateMatrixWorld();

              controllerMesh.rayDot.position.z = -distance;
              controllerMesh.updateMatrixWorld();
              controllerMesh.rayDot.visible = true;

              for (let i = 0; i < keyMap.length; i++) {
                const [key, kx1, ky1, kx2, ky2] = keyMap[i];
                if (x >= kx1 && x < kx2 && y >= ky1 && y < ky2) {
                  if (keyboardHighlightCanvasCtx) {
                    const width = kx2 - kx1;
                    const height = ky2 - ky1;
                    let imageData = keyboardHighlightCanvasCtx.getImageData(kx1, ky1, width, height);
                    /* if (key === 'enter') { // special case the enter key; it has a non-rectangular shape
                      const canvas = document.createElement('canvas');
                      canvas.width = imageData.width;
                      canvas.height = imageData.height;

                      const ctx = canvas.getContext('2d');
                      ctx.putImageData(imageData, 0, 0);
                      ctx.clearRect(0, 0, 80, 140);

                      imageData = ctx.getImageData(0, 0, imageData.width, imageData.height);
                    } */

                    controllerMesh.keyMesh.material.map.image = imageData;
                    controllerMesh.keyMesh.material.map.needsUpdate = true;

                    controllerMesh.keyMesh.position
                      .set(
                        -1/2 + ((width/2 + kx1) / keyboardWidth),
                        (keyboardHeight / keyboardWidth)/2 - ((height/2 + ky1) / keyboardHeight * (keyboardHeight / keyboardWidth)),
                         0.01 * (pressed ? 0.5 : 1)
                      );
                    controllerMesh.keyMesh.scale.set(
                      width / keyboardWidth,
                      height / keyboardHeight * (keyboardHeight / keyboardWidth),
                      1
                    );
                    controllerMesh.keyMesh.updateMatrixWorld();
                    controllerMesh.keyMesh.visible = true;
                  }

                  intersectionKey = key;

                  break;
                }
              }
            } else {
              intersectionPoint = null;
            }
          }

          // menu mesh
          let tabIndex = -1;
          let urlCoords = null;
          let intersectionRect = null;
          let appIndex = -1;
          let fileIndex = -1;
          let fileRemove = false;
          let serverIndex = -1;
          let loginHovered = false;
          let voicechatHovered = false;
          let loginCoords = null;
          if (!intersectionPoint) {
            intersectionPoint = menuMesh.visible ? controllerMesh.ray.intersectPlane(menuMesh.urlMesh.plane, localVector) : null;
            if (intersectionPoint) {
              const leftIntersectionPoint = menuMesh.urlMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

              const topIntersectionPoint = menuMesh.urlMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

              const xFactor = topIntersectionPoint.distanceTo(menuMesh.urlMesh.topLine.start) / menuWorldWidth;
              const yFactor = leftIntersectionPoint.distanceTo(menuMesh.urlMesh.leftLine.start) / menuWorldHeight;
              const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

              if (xFactor > 0 && xFactor <= 0.99 && yFactor > 0 && yFactor <= 0.99 && distance < rayDistance) {
                const x = xFactor * menuWidth;
                const y = yFactor * menuHeight;

                const tab = _getTab();
                  if (tab === 'URL') {
                    if (y < urlBarOffset*2) {
                      urlCoords = [x, y];

                      controllerMesh.rayMesh.scale.z = distance;
                      controllerMesh.updateMatrixWorld();

                      controllerMesh.rayDot.position.z = -distance;
                      controllerMesh.updateMatrixWorld();
                      controllerMesh.rayDot.visible = true;
                    } else {
                      intersectionPoint = null;
                    }
                  }
                  else {
                    intersectionPoint = null;
                  }
              } else {
                intersectionPoint = null;
              }
            }
          }

          if (!intersectionPoint) {
            _setIntersectionDefault();
          }

          const lastPressed = lastPresseds[i];
          lastPresseds[i] = pressed;
          if (pressed && !lastPressed) {


            const grabbedObject = grabbedObjects[i];
            if (intersectionRect) {
              if (intersectionRect.click) {
                // console.log('eval click', intersectionRect.click); // XXX
                _renderHtml(intersectionRect.click);
              } else if (intersectionRect.tagName === 'A' && intersectionRect.href) {
                console.log('eval href', intersectionRect.href); // XXX
              } else {
                // nothing
              }
            } else if (intersectionKey) {
              const code = keyCode(intersectionKey);
              _handleKey(code, false);
            } else if (tabIndex !== -1) {
              currentTabIndex = tabIndex;

              const tab = _getTab();
              if (tab === 'URL') {
                keyboardState = urlState;
              }


              menuMesh.urlMesh.updateText();
            }
          }
        }
      };


      _updateControllers();
      _updateIntersections();

    }

    const _handleDefaultKey = (code, shiftKey) => {
      let c = String.fromCharCode(code);
      if (shiftKey) {
        c = c.toUpperCase();
      }
      keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + c + keyboardState.text.slice(keyboardState.cursor);
      keyboardState.cursor++;
      menuMesh.urlMesh.updateText();
    };
    const _handleKey = (code, shiftKey) => {
      if (code === 8) { // backspace
        if (keyboardState.cursor > 0) {
          keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor - 1) + keyboardState.text.slice(keyboardState.cursor);
          keyboardState.cursor--;
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 46) { // delete
        if (keyboardState.cursor < keyboardState.text.length) {
          keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + keyboardState.text.slice(keyboardState.cursor + 1);
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 32) { // space
        keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + ' ' + keyboardState.text.slice(keyboardState.cursor);
        keyboardState.cursor++;
        menuMesh.urlMesh.updateText();
      } else if (code === 13) { // enter
        keyboardState.submit();
      } else if (
        code === 9 || // tab
        code === 16 || // shift
        code === 17 || // ctrl
        code === 18 || // alt
        code === 20 || // capslock
        code === 27 || // esc
        code === 91 // win
      ) {
        // nothing
      } else if (code === 37) { // left
        keyboardState.cursor = Math.max(keyboardState.cursor - 1, 0);
        menuMesh.urlMesh.updateText();
      } else if (code === 39) { // right
        keyboardState.cursor = Math.min(keyboardState.cursor + 1, keyboardState.text.length);
        menuMesh.urlMesh.updateText();
      } else if (code === 38) { // up
        keyboardState.cursor = 0;
        menuMesh.urlMesh.updateText();
      } else if (code === 40) { // down
        keyboardState.cursor = keyboardState.text.length;
        menuMesh.urlMesh.updateText();
      } else if (code === -1) {
        // nothing
      } else {
        _handleDefaultKey(code, shiftKey);
      }
    };



    const resources = [];
    const _resourcesUpdate = () => {
      let value = 0;
      let total =  0;
      for (let i = 0; i < resources.length; i++) {
        for (let j = 0; j < resources[i].resources.length; j++) {
          const resource = resources[i].resources[j];
          value += resource.value;
          total += resource.total;
        }
      }
      loadingBarState.value = value;
      loadingBarState.total = total;
      loadingBarState.progress = loadingBarState.total > 0 ? (loadingBarState.value/loadingBarState.total) : 0;
      menuMesh.urlMesh.updateText();
    };
    if (window.document.resources) {
      resources.push(window.document.resources);
    }
    for (let i = 0; i < resources.length; i++) {
      window.document.resources.addEventListener('update', _resourcesUpdate);
    }


})();
  </script>
</body>
</html>
